// RobotBuilder Version: 0.0.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
/*package org.usfirst.frc2791.MyRobot.commands;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc2791.MyRobot.OI;
import org.usfirst.frc2791.MyRobot.Robot;
import org.usfirst.frc2791.MyRobot.RobotMap;
import edu.wpi.first.wpilibj.DriverStationLCD;

/**
 
public class  JoystickThree extends Command {
    public JoystickThree() {
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);
	
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }
    // Called just before this Command runs the first time
    protected void initialize() {
    }
    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
        //RobotMap.wd.feed();
        //RobotMap.armEncoder.reset();
       // RobotMap.armEncoder.start();
        //RobotMap.armMotor.set(-OI.joystick3.getY());
        //Robot.ds.println(DriverStationLCD.Line.kUser4,1,"ArmEcoder: "+OI.joystick3.getY());
//Robot.ds.println(DriverStationLCD.Line.kUser3,1,"ArmEcoderTESTTTTTTTTT: "+RobotMap.armEncoder.get());
        Robot.ds.updateLCD();
        int minDist = 0;
        int maxDist = 10000;
        double x = 0.0;//0.2
        int tolerance = 50;
        
        Robot.ds.println(DriverStationLCD.Line.kUser6,1,"testttttttttttttttt please work           ");
        
        double zValue = ((OI.joystick3.getZ()+1)/2);
        int setDist = (int) (zValue*maxDist);
        if (OI.joystick3.getY()>=0.2)
        {
            x=OI.joystick3.getY();
            Robot.ds.println(DriverStationLCD.Line.kUser6,1,"this is greater than 0.2");
            
        }
        if (OI.joystick3.getY()<=-0.2)
        {
            x=OI.joystick3.getY();
            Robot.ds.println(DriverStationLCD.Line.kUser6,1,"this is less than 0.2");
        }
        //Robot.ds.println(DriverStationLCD.Line.kUser3,1,"Joystick.getY Reading:  "+OI.joystick3.getY());
        //Robot.ds.updateLCD();
        //if (OI.joystick3.getZ()>=0.2)
        //{
            
        //}
        if ((RobotMap.limitSwitch.get()==false))//changed from true to false
        {
            RobotMap.armEncoder.reset();
            
        }
                
        if ((RobotMap.armEncoder.get()>=setDist-tolerance)||(RobotMap.armEncoder.get()<=setDist+tolerance))
        {
            RobotMap.armMotor.set(0);
        }
        if ((RobotMap.armEncoder.get()>setDist+tolerance))
        {
            RobotMap.armMotor.set(-x); //assumes arm moves down
        }
        if ((RobotMap.armEncoder.get()<setDist-tolerance))
        {
            RobotMap.armMotor.set(x); // assumes arm moves up
        }
        
           /*if (zValue>0.5)
             {
            RobotMap.armMotor.set(-x);
            if (setDist == RobotMap.armEncoder.get()) //remember could be getDistance
                {
                RobotMap.armMotor.set(0);
                }
             }
        if (zValue<0.5)
        {
            RobotMap.armMotor.set(x);
            if (setDist == RobotMap.armEncoder.get()) //remember could be getDistance
            {
                RobotMap.armMotor.set(0);
            }
        }
        if (zValue==0.5)
         {
            RobotMap.armMotor.set(0);
            }*/
        
        
        
        
        
        /*if ((RobotMap.limitSwitch.get()==true)&&(OI.joystick3.getZ()<=0))
        {
            RobotMap.armMotor.set(0);
        }
        if ((RobotMap.limitSwitch.get()==true)&&(OI.joystick3.getZ()>0))
        {
            RobotMap.armMotor.set(OI.joystick3.getZ());
        }
        if((RobotMap.limitSwitch.get()==false)&&(OI.joystick3.getZ()>=-0.2)&&(OI.joystick3.getZ()<=0.2))
        {
            Robot.ds.println(DriverStationLCD.Line.kUser4,1,"DEAD ZONE: BEWARE...");
            RobotMap.armMotor.set(0);
        }
        if((RobotMap.limitSwitch.get()==false)&&(OI.joystick3.getZ()<-0.2)&&(OI.joystick3.getZ()>0.2))
        {
            RobotMap.armMotor.set(OI.joystick3.getZ());
        }
        
        
 //uncomment later      // Robot.ds.println(DriverStationLCD.Line.kUser3,1,"encoderArm: "+RobotMap.armEncoder.get()+"                             ");
       // Robot.ds.updateLCD();
        
        //cam = AxisCamera.getInstance();
        //cam.writeResolution(AxisCamera.ResolutionT.k160x120);
        //cam.writeBrightness(50);
        double c = 0.0;
        double s = 0.0;
        
        if(OI.joystick3.getRawButton(2))
        {
            RobotMap.compressor.start();
        }
        if(OI.joystick3.getRawButton(3))
        {
            RobotMap.VexMotor.set(-1);
            RobotMap.timz.start();
            if (RobotMap.timz.get()==0.5)
            {
                RobotMap.VexMotor.set(0);
            }
            
            //s=RobotMap.servo.getAngle();
            //s=s+324.0;
            //RobotMap.servo.setAngle(s);
        }
        if (OI.joystick3.getRawButton(4))
        {
            RobotMap.shooterWheelClose.set(-1);
            RobotMap.shooterWheelFar.set(-1);
        }
        if (OI.joystick3.getRawButton(5))
        {
            RobotMap.shooterWheelClose.set(c);
            RobotMap.shooterWheelFar.set(c);
        }
        if(OI.joystick3.getTrigger()==true)
        {
            RobotMap.solenoid.set(false);
        }
        if(OI.joystick3.getTrigger()==false)
        {
            RobotMap.solenoid.set(true);
        }
        
    }
    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }
    // Called once after isFinished returns true
    protected void end() {
    }
    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
        end();
    }
}
*/